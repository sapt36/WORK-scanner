1  PREP  #include <stdlib.h>
2  PREP  #include <stdio.h>
3  PREP  #include <string.h>
4  PREP  #include <ctype.h>
6  REWD  struct
6  IDEN  token
7  SPEC  {
8  REWD  int
8  IDEN  flag
8  SPEC  ;
9  REWD  int
9  IDEN  s
9  SPEC  ;
9  SC  //
9  IDEN  Start
9  IDEN  line
9  IDEN  number
10  REWD  int
10  IDEN  e
10  SPEC  ;
10  SC  //
10  IDEN  End
10  IDEN  line
10  IDEN  number
11  REWD  char
11  OPER  *
11  IDEN  token
11  SPEC  ;
11  SC  //
11  IDEN  Type
11  IDEN  of
11  IDEN  the
11  IDEN  token
12  REWD  char
12  IDEN  word
12  OPER  [
12  INTE  100
12  OPER  ]
12  SPEC  ;
12  SC  //
12  IDEN  Token
12  IDEN  word
13  SPEC  }
13  IDEN  token_list
13  OPER  [
13  INTE  10000
13  OPER  ]
13  SPEC  ;
15  SC  //
15  IDEN  stores
15  IDEN  reserved
15  IDEN  words
15  IDEN  in
15  IDEN  C
16  REWD  char
16  OPER  *
16  IDEN  REWD
16  OPER  [
16  OPER  ]
16  OPER  =
16  SPEC  {
16  STR  "
16  REWD  if
16  STR  "
16  OPER  ,
16  STR  "
16  REWD  else
16  STR  "
16  OPER  ,
16  STR  "
16  REWD  while
16  STR  "
16  OPER  ,
16  STR  "
16  REWD  for
16  STR  "
16  OPER  ,
16  STR  "
16  REWD  do
16  STR  "
16  OPER  ,
16  STR  "
16  REWD  switch
16  STR  "
16  OPER  ,
16  STR  "
16  REWD  case
16  STR  "
16  OPER  ,
16  STR  "
16  REWD  default
16  STR  "
16  OPER  ,
16  STR  "
16  REWD  continue
16  STR  "
16  OPER  ,
16  STR  "
16  REWD  int
16  STR  "
16  OPER  ,
16  STR  "
16  REWD  long
16  STR  "
16  OPER  ,
16  STR  "
16  REWD  float
16  STR  "
16  OPER  ,
16  STR  "
16  REWD  double
16  STR  "
16  OPER  ,
16  STR  "
16  REWD  char
16  STR  "
16  OPER  ,
16  STR  "
16  REWD  break
16  STR  "
16  OPER  ,
16  STR  "
16  REWD  static
16  STR  "
16  OPER  ,
16  STR  "
16  REWD  extern
16  STR  "
16  OPER  ,
16  STR  "
16  REWD  auto
16  STR  "
16  OPER  ,
16  STR  "
16  REWD  register
16  STR  "
16  OPER  ,
16  STR  "
16  REWD  sizeof
16  STR  "
16  OPER  ,
16  STR  "
16  REWD  union
16  STR  "
16  OPER  ,
16  STR  "
16  REWD  struct
16  STR  "
16  OPER  ,
16  STR  "
16  REWD  short
16  STR  "
16  OPER  ,
16  STR  "
16  REWD  enum
16  STR  "
16  OPER  ,
16  STR  "
16  REWD  return
16  STR  "
16  OPER  ,
16  STR  "
16  REWD  goto
16  STR  "
16  OPER  ,
16  STR  "
16  REWD  const
16  STR  "
16  OPER  ,
16  STR  "
16  REWD  signed
16  STR  "
16  OPER  ,
16  STR  "
16  REWD  unsigned
16  STR  "
16  OPER  ,
16  STR  "
16  REWD  typedef
16  STR  "
16  OPER  ,
16  STR  "
16  REWD  void
16  STR  "
16  SPEC  }
16  SPEC  ;
17  REWD  char
17  IDEN  program
17  OPER  [
17  INTE  10000
17  OPER  ]
17  SPEC  ;
18  REWD  int
18  IDEN  cur_i
18  OPER  =
18  INTE  0
18  SPEC  ;
18  SC  //
18  IDEN  Current
18  REWD  char
18  IDEN  index
19  REWD  int
19  IDEN  s
19  OPER  =
19  INTE  1
19  SPEC  ;
19  SC  //
19  IDEN  Line
19  IDEN  number
20  REWD  int
20  IDEN  index
20  OPER  =
20  INTE  0
20  SPEC  ;
20  SC  //
20  IDEN  Token
20  IDEN  list
20  IDEN  index
22  SC  //
22  IDEN  Function
22  IDEN  to
22  IDEN  identify
22  IDEN  an
22  IDEN  identifier
22  IDEN  token
23  REWD  void
23  IDEN  identifier
23  SPEC  (
23  SPEC  )
24  SPEC  {
25  REWD  char
25  IDEN  iden
25  OPER  [
25  INTE  100
25  OPER  ]
25  SPEC  ;
26  REWD  int
26  IDEN  i
26  OPER  =
26  INTE  0
26  SPEC  ;
27  REWD  while
27  SPEC  (
27  IDEN  isalnum
27  SPEC  (
27  IDEN  program
27  OPER  [
27  IDEN  cur_i
27  OPER  ]
27  SPEC  )
27  OPER  |
27  IDEN  program
27  OPER  [
27  IDEN  cur_i
27  OPER  ]
27  OPER  =
27  CHAR  '
27  IDEN  _
27  CHAR  '
27  SPEC  )
28  SPEC  {
29  IDEN  iden
29  OPER  [
29  IDEN  i
29  OPER  ]
29  OPER  =
29  IDEN  program
29  OPER  [
29  IDEN  cur_i
29  OPER  ]
29  SPEC  ;
30  IDEN  i
30  INTE  +
30  OPER  =
30  INTE  1
30  SPEC  ;
31  IDEN  cur_i
31  INTE  +
31  OPER  =
31  INTE  1
31  SPEC  ;
32  SPEC  }
33  IDEN  iden
33  OPER  [
33  IDEN  i
33  OPER  ]
33  OPER  =
33  CHAR  '
33  OPER  \
33  INTE  0
33  CHAR  '
33  SPEC  ;
35  REWD  int
35  IDEN  is_rewd
35  OPER  =
35  INTE  0
35  SPEC  ;
36  REWD  for
36  SPEC  (
36  REWD  int
36  IDEN  j
36  OPER  =
36  INTE  0
36  SPEC  ;
36  IDEN  j
36  OPER  <
36  INTE  31
36  SPEC  ;
36  IDEN  j
36  INTE  ++
36  SPEC  )
37  SPEC  {
38  REWD  if
38  SPEC  (
38  IDEN  strcmp
38  SPEC  (
38  IDEN  iden
38  OPER  ,
38  IDEN  REWD
38  OPER  [
38  IDEN  j
38  OPER  ]
38  SPEC  )
38  OPER  =
38  INTE  0
38  SPEC  )
39  SPEC  {
40  IDEN  is_rewd
40  OPER  =
40  INTE  1
40  SPEC  ;
41  REWD  break
41  SPEC  ;
42  SPEC  }
43  SPEC  }
45  REWD  if
45  SPEC  (
45  IDEN  is_rewd
45  SPEC  )
46  SPEC  {
47  IDEN  token_list
47  OPER  [
47  IDEN  index
47  OPER  ]
47  FLOT  .
47  IDEN  s
47  OPER  =
47  IDEN  s
47  SPEC  ;
48  IDEN  token_list
48  OPER  [
48  IDEN  index
48  OPER  ]
48  FLOT  .
48  IDEN  token
48  OPER  =
48  STR  "
48  IDEN  REWD
48  STR  "
48  SPEC  ;
49  IDEN  strcpy
49  SPEC  (
49  IDEN  token_list
49  OPER  [
49  IDEN  index
49  OPER  ]
49  FLOT  .
49  IDEN  word
49  OPER  ,
49  IDEN  iden
49  SPEC  )
49  SPEC  ;
50  IDEN  index
50  INTE  +
50  OPER  =
50  INTE  1
50  SPEC  ;
51  SPEC  }
52  REWD  else
53  SPEC  {
54  IDEN  token_list
54  OPER  [
54  IDEN  index
54  OPER  ]
54  FLOT  .
54  IDEN  s
54  OPER  =
54  IDEN  s
54  SPEC  ;
55  IDEN  token_list
55  OPER  [
55  IDEN  index
55  OPER  ]
55  FLOT  .
55  IDEN  token
55  OPER  =
55  STR  "
55  IDEN  IDEN
55  STR  "
55  SPEC  ;
56  IDEN  strcpy
56  SPEC  (
56  IDEN  token_list
56  OPER  [
56  IDEN  index
56  OPER  ]
56  FLOT  .
56  IDEN  word
56  OPER  ,
56  IDEN  iden
56  SPEC  )
56  SPEC  ;
57  IDEN  index
57  INTE  +
57  OPER  =
57  INTE  1
57  SPEC  ;
58  SPEC  }
59  SPEC  }
61  SC  //
61  IDEN  Function
61  IDEN  to
61  IDEN  identify
61  IDEN  a
61  IDEN  number
61  IDEN  token
62  REWD  void
62  IDEN  number
62  SPEC  (
62  SPEC  )
63  SPEC  {
64  REWD  char
64  IDEN  number
64  OPER  [
64  INTE  100
64  OPER  ]
64  SPEC  ;
65  REWD  int
65  IDEN  i
65  OPER  =
65  INTE  0
65  SPEC  ;
66  REWD  int
66  IDEN  is_float
66  OPER  =
66  INTE  0
66  SPEC  ;
67  REWD  int
67  IDEN  is_exp
67  OPER  =
67  INTE  0
67  SPEC  ;
68  REWD  while
68  SPEC  (
68  IDEN  isdigit
68  SPEC  (
68  IDEN  program
68  OPER  [
68  IDEN  cur_i
68  OPER  ]
68  SPEC  )
68  OPER  |
68  IDEN  program
68  OPER  [
68  IDEN  cur_i
68  OPER  ]
68  OPER  =
68  CHAR  '
68  FLOT  .
68  CHAR  '
68  OPER  |
68  IDEN  program
68  OPER  [
68  IDEN  cur_i
68  OPER  ]
68  OPER  =
68  CHAR  '
68  IDEN  e
68  CHAR  '
68  OPER  |
68  IDEN  program
68  OPER  [
68  IDEN  cur_i
68  OPER  ]
68  OPER  =
68  CHAR  '
68  IDEN  E
68  CHAR  '
68  OPER  |
68  IDEN  program
68  OPER  [
68  IDEN  cur_i
68  OPER  ]
68  OPER  =
68  CHAR  '
68  INTE  +
68  CHAR  '
68  OPER  |
68  IDEN  program
68  OPER  [
68  IDEN  cur_i
68  OPER  ]
68  OPER  =
68  CHAR  '
68  INTE  -
68  CHAR  '
68  SPEC  )
69  SPEC  {
70  REWD  if
70  SPEC  (
70  IDEN  program
70  OPER  [
70  IDEN  cur_i
70  OPER  ]
70  OPER  =
70  CHAR  '
70  FLOT  .
70  CHAR  '
70  SPEC  )
71  SPEC  {
72  IDEN  is_float
72  OPER  =
72  INTE  1
72  SPEC  ;
73  SPEC  }
74  REWD  if
74  SPEC  (
74  IDEN  program
74  OPER  [
74  IDEN  cur_i
74  OPER  ]
74  OPER  =
74  CHAR  '
74  IDEN  e
74  CHAR  '
74  OPER  |
74  IDEN  program
74  OPER  [
74  IDEN  cur_i
74  OPER  ]
74  OPER  =
74  CHAR  '
74  IDEN  E
74  CHAR  '
74  SPEC  )
75  SPEC  {
76  IDEN  is_exp
76  OPER  =
76  INTE  1
76  SPEC  ;
77  SPEC  }
78  IDEN  number
78  OPER  [
78  IDEN  i
78  OPER  ]
78  OPER  =
78  IDEN  program
78  OPER  [
78  IDEN  cur_i
78  OPER  ]
78  SPEC  ;
79  IDEN  i
79  INTE  +
79  OPER  =
79  INTE  1
79  SPEC  ;
80  IDEN  cur_i
80  INTE  +
80  OPER  =
80  INTE  1
80  SPEC  ;
81  SPEC  }
82  IDEN  number
82  OPER  [
82  IDEN  i
82  OPER  ]
82  OPER  =
82  CHAR  '
82  OPER  \
82  INTE  0
82  CHAR  '
82  SPEC  ;
84  REWD  if
84  SPEC  (
84  IDEN  is_float
84  OPER  |
84  IDEN  is_exp
84  SPEC  )
85  SPEC  {
86  IDEN  token_list
86  OPER  [
86  IDEN  index
86  OPER  ]
86  FLOT  .
86  IDEN  s
86  OPER  =
86  IDEN  s
86  SPEC  ;
87  IDEN  token_list
87  OPER  [
87  IDEN  index
87  OPER  ]
87  FLOT  .
87  IDEN  token
87  OPER  =
87  STR  "
87  IDEN  FLOT
87  STR  "
87  SPEC  ;
88  IDEN  strcpy
88  SPEC  (
88  IDEN  token_list
88  OPER  [
88  IDEN  index
88  OPER  ]
88  FLOT  .
88  IDEN  word
88  OPER  ,
88  IDEN  number
88  SPEC  )
88  SPEC  ;
89  IDEN  index
89  INTE  +
89  OPER  =
89  INTE  1
89  SPEC  ;
90  SPEC  }
91  REWD  else
92  SPEC  {
93  IDEN  token_list
93  OPER  [
93  IDEN  index
93  OPER  ]
93  FLOT  .
93  IDEN  s
93  OPER  =
93  IDEN  s
93  SPEC  ;
94  IDEN  token_list
94  OPER  [
94  IDEN  index
94  OPER  ]
94  FLOT  .
94  IDEN  token
94  OPER  =
94  STR  "
94  IDEN  INTE
94  STR  "
94  SPEC  ;
95  IDEN  strcpy
95  SPEC  (
95  IDEN  token_list
95  OPER  [
95  IDEN  index
95  OPER  ]
95  FLOT  .
95  IDEN  word
95  OPER  ,
95  IDEN  number
95  SPEC  )
95  SPEC  ;
96  IDEN  index
96  INTE  +
96  OPER  =
96  INTE  1
96  SPEC  ;
97  SPEC  }
98  SPEC  }
100  REWD  char
100  IDEN  CHAR
100  OPER  =
100  CHAR  '
100  OPER  \
100  CHAR  '
100  CHAR  '
100  SPEC  ;
101  REWD  char
101  IDEN  STR
101  OPER  =
101  CHAR  '
101  OPER  \
101  STR  "
101  CHAR  '
101  SPEC  ;
103  REWD  char
103  OPER  *
103  IDEN  OPER
103  OPER  [
103  OPER  ]
103  OPER  =
103  SPEC  {
103  STR  "
103  INTE  +
103  STR  "
103  OPER  ,
103  STR  "
103  INTE  -
103  STR  "
103  OPER  ,
103  STR  "
103  OPER  *
103  STR  "
103  OPER  ,
103  STR  "
103  OPER  /
103  STR  "
103  OPER  ,
103  STR  "
103  OPER  =
103  STR  "
103  OPER  ,
103  STR  "
103  OPER  ,
103  STR  "
103  OPER  ,
103  STR  "
103  OPER  %
103  STR  "
103  OPER  ,
103  STR  "
103  OPER  >
103  STR  "
103  OPER  ,
103  STR  "
103  OPER  <
103  STR  "
103  OPER  ,
103  STR  "
103  INTE  ++
103  STR  "
103  OPER  ,
103  STR  "
103  INTE  --
103  STR  "
103  OPER  ,
103  STR  "
103  INTE  +
103  OPER  =
103  STR  "
103  OPER  ,
103  STR  "
103  INTE  -
103  OPER  =
103  STR  "
103  OPER  ,
103  STR  "
103  OPER  =
103  STR  "
103  OPER  ,
104  STR  "
104  OPER  =
104  STR  "
104  OPER  ,
104  STR  "
104  OPER  =
104  STR  "
104  OPER  ,
104  STR  "
104  OPER  !
104  STR  "
104  OPER  ,
104  STR  "
104  OPER  &
104  STR  "
104  OPER  ,
104  STR  "
104  OPER  |
104  STR  "
104  OPER  ,
104  STR  "
104  OPER  &
104  STR  "
104  OPER  ,
104  STR  "
104  OPER  [
104  STR  "
104  OPER  ,
104  STR  "
104  OPER  ]
104  STR  "
104  OPER  ,
104  STR  "
104  OPER  |
104  STR  "
104  OPER  ,
104  STR  "
104  OPER  ^
104  STR  "
104  OPER  ,
104  STR  "
104  FLOT  .
104  STR  "
104  OPER  ,
104  STR  "
104  INTE  -
104  OPER  >
104  STR  "
104  OPER  ,
104  STR  "
104  OPER  >
104  STR  "
104  OPER  ,
104  STR  "
104  OPER  <
104  STR  "
104  OPER  ,
104  STR  "
104  OPER  =
104  STR  "
104  OPER  ,
104  STR  "
104  OPER  =
104  STR  "
104  OPER  ,
104  STR  "
104  OPER  =
104  STR  "
104  OPER  ,
104  STR  "
104  OPER  =
104  STR  "
104  SPEC  }
104  SPEC  ;
105  REWD  char
105  IDEN  SPEC
105  OPER  [
105  OPER  ]
105  OPER  =
105  SPEC  {
105  CHAR  '
105  SPEC  {
105  CHAR  '
105  OPER  ,
105  CHAR  '
105  SPEC  }
105  CHAR  '
105  OPER  ,
105  CHAR  '
105  SPEC  (
105  CHAR  '
105  OPER  ,
105  CHAR  '
105  SPEC  )
105  CHAR  '
105  OPER  ,
105  CHAR  '
105  SPEC  ;
105  CHAR  '
105  OPER  ,
105  CHAR  '
105  SPEC  ?
105  CHAR  '
105  OPER  ,
105  CHAR  '
105  SPEC  :
105  CHAR  '
105  SPEC  }
105  SPEC  ;
106  REWD  char
106  OPER  *
106  IDEN  SC
106  OPER  =
106  STR  "
106  SC  //
106  STR  "
106  SPEC  ;
107  REWD  char
107  OPER  *
107  IDEN  MC
107  OPER  [
107  OPER  ]
107  OPER  =
107  SPEC  {
107  STR  "
107  MC  /*
107  STR  "
107  SPEC  }
107  SPEC  ;
108  REWD  char
108  IDEN  PREP
108  OPER  =
108  CHAR  '
108  PREP  #';
110  SC  //
110  IDEN  Function
110  IDEN  to
110  IDEN  check
110  REWD  if
110  IDEN  a
110  IDEN  character
110  IDEN  is
110  IDEN  a
110  IDEN  special
110  IDEN  symbol
111  REWD  int
111  IDEN  check_spec
111  SPEC  (
111  REWD  char
111  IDEN  c
111  SPEC  )
112  SPEC  {
113  REWD  for
113  SPEC  (
113  IDEN  size_t
113  IDEN  i
113  OPER  =
113  INTE  0
113  SPEC  ;
113  IDEN  i
113  OPER  <
113  INTE  7
113  SPEC  ;
113  IDEN  i
113  INTE  ++
113  SPEC  )
114  SPEC  {
115  REWD  if
115  SPEC  (
115  IDEN  c
115  OPER  =
115  IDEN  SPEC
115  OPER  [
115  IDEN  i
115  OPER  ]
115  SPEC  )
116  SPEC  {
117  REWD  return
117  INTE  1
117  SPEC  ;
118  SPEC  }
119  SPEC  }
120  REWD  return
120  INTE  -1
120  SPEC  ;
121  SPEC  }
123  SC  //
123  IDEN  Function
123  IDEN  to
123  IDEN  identify
123  IDEN  special
123  IDEN  symbol
123  IDEN  tokens
124  REWD  void
124  IDEN  special_symbols
124  SPEC  (
124  SPEC  )
125  SPEC  {
126  REWD  char
126  IDEN  c
126  OPER  =
126  IDEN  program
126  OPER  [
126  IDEN  cur_i
126  OPER  ]
126  SPEC  ;
127  REWD  if
127  SPEC  (
127  IDEN  c
127  OPER  =
127  IDEN  CHAR
127  SPEC  )
128  SPEC  {
129  IDEN  token_list
129  OPER  [
129  IDEN  index
129  OPER  ]
129  FLOT  .
129  IDEN  s
129  OPER  =
129  IDEN  s
129  SPEC  ;
130  IDEN  token_list
130  OPER  [
130  IDEN  index
130  OPER  ]
130  FLOT  .
130  IDEN  token
130  OPER  =
130  STR  "
130  IDEN  CHAR
130  STR  "
130  SPEC  ;
131  IDEN  token_list
131  OPER  [
131  IDEN  index
131  OPER  ]
131  FLOT  .
131  IDEN  word
131  OPER  [
131  INTE  0
131  OPER  ]
131  OPER  =
131  IDEN  c
131  SPEC  ;
132  IDEN  index
132  INTE  +
132  OPER  =
132  INTE  1
132  SPEC  ;
133  IDEN  cur_i
133  INTE  +
133  OPER  =
133  INTE  1
133  SPEC  ;
134  SPEC  }
135  REWD  else
135  REWD  if
135  SPEC  (
135  IDEN  c
135  OPER  =
135  IDEN  STR
135  SPEC  )
136  SPEC  {
137  IDEN  token_list
137  OPER  [
137  IDEN  index
137  OPER  ]
137  FLOT  .
137  IDEN  s
137  OPER  =
137  IDEN  s
137  SPEC  ;
138  IDEN  token_list
138  OPER  [
138  IDEN  index
138  OPER  ]
138  FLOT  .
138  IDEN  token
138  OPER  =
138  STR  "
138  IDEN  STR
138  STR  "
138  SPEC  ;
139  IDEN  token_list
139  OPER  [
139  IDEN  index
139  OPER  ]
139  FLOT  .
139  IDEN  word
139  OPER  [
139  INTE  0
139  OPER  ]
139  OPER  =
139  IDEN  c
139  SPEC  ;
140  IDEN  index
140  INTE  +
140  OPER  =
140  INTE  1
140  SPEC  ;
141  IDEN  cur_i
141  INTE  +
141  OPER  =
141  INTE  1
141  SPEC  ;
142  SPEC  }
143  REWD  else
143  REWD  if
143  SPEC  (
143  IDEN  c
143  OPER  =
143  IDEN  PREP
143  SPEC  )
144  SPEC  {
145  IDEN  token_list
145  OPER  [
145  IDEN  index
145  OPER  ]
145  FLOT  .
145  IDEN  s
145  OPER  =
145  IDEN  s
145  SPEC  ;
146  IDEN  token_list
146  OPER  [
146  IDEN  index
146  OPER  ]
146  FLOT  .
146  IDEN  token
146  OPER  =
146  STR  "
146  IDEN  PREP
146  STR  "
146  SPEC  ;
147  REWD  int
147  IDEN  i
147  OPER  =
147  INTE  0
147  SPEC  ;
148  REWD  while
148  SPEC  (
148  IDEN  program
148  OPER  [
148  IDEN  cur_i
148  OPER  ]
148  OPER  =
148  CHAR  '
148  OPER  \
148  IDEN  n
148  CHAR  '
148  SPEC  )
149  SPEC  {
150  IDEN  token_list
150  OPER  [
150  IDEN  index
150  OPER  ]
150  FLOT  .
150  IDEN  word
150  OPER  [
150  IDEN  i
150  OPER  ]
150  OPER  =
150  IDEN  program
150  OPER  [
150  IDEN  cur_i
150  OPER  ]
150  SPEC  ;
151  IDEN  cur_i
151  INTE  +
151  OPER  =
151  INTE  1
151  SPEC  ;
152  IDEN  i
152  INTE  +
152  OPER  =
152  INTE  1
152  SPEC  ;
153  SPEC  }
154  IDEN  index
154  INTE  +
154  OPER  =
154  INTE  1
154  SPEC  ;
155  SPEC  }
156  REWD  else
157  SPEC  {
158  REWD  if
158  SPEC  (
158  IDEN  c
158  OPER  =
158  CHAR  '
158  OPER  /
158  CHAR  '
158  OPER  &
158  IDEN  program
158  OPER  [
158  IDEN  cur_i
158  INTE  +
158  INTE  1
158  OPER  ]
158  OPER  =
158  CHAR  '
158  OPER  /
158  CHAR  '
158  SPEC  )
159  SPEC  {
160  IDEN  token_list
160  OPER  [
160  IDEN  index
160  OPER  ]
160  FLOT  .
160  IDEN  s
160  OPER  =
160  IDEN  s
160  SPEC  ;
161  IDEN  token_list
161  OPER  [
161  IDEN  index
161  OPER  ]
161  FLOT  .
161  IDEN  token
161  OPER  =
161  STR  "
161  IDEN  SC
161  STR  "
161  SPEC  ;
162  IDEN  token_list
162  OPER  [
162  IDEN  index
162  OPER  ]
162  FLOT  .
162  IDEN  word
162  OPER  [
162  INTE  0
162  OPER  ]
162  OPER  =
162  IDEN  c
162  SPEC  ;
163  IDEN  token_list
163  OPER  [
163  IDEN  index
163  OPER  ]
163  FLOT  .
163  IDEN  word
163  OPER  [
163  INTE  1
163  OPER  ]
163  OPER  =
163  IDEN  program
163  OPER  [
163  IDEN  cur_i
163  INTE  +
163  INTE  1
163  OPER  ]
163  SPEC  ;
164  IDEN  index
164  INTE  +
164  OPER  =
164  INTE  1
164  SPEC  ;
165  IDEN  cur_i
165  INTE  +
165  OPER  =
165  INTE  2
165  SPEC  ;
166  SPEC  }
167  REWD  else
167  REWD  if
167  SPEC  (
167  IDEN  c
167  OPER  =
167  CHAR  '
167  OPER  /
167  CHAR  '
167  OPER  &
167  IDEN  program
167  OPER  [
167  IDEN  cur_i
167  INTE  +
167  INTE  1
167  OPER  ]
167  OPER  =
167  CHAR  '
167  OPER  *
167  CHAR  '
167  SPEC  )
168  SPEC  {
169  IDEN  token_list
169  OPER  [
169  IDEN  index
169  OPER  ]
169  FLOT  .
169  IDEN  s
169  OPER  =
169  IDEN  s
169  SPEC  ;
170  IDEN  token_list
170  OPER  [
170  IDEN  index
170  OPER  ]
170  FLOT  .
170  IDEN  token
170  OPER  =
170  STR  "
170  IDEN  MC
170  STR  "
170  SPEC  ;
171  IDEN  token_list
171  OPER  [
171  IDEN  index
171  OPER  ]
171  FLOT  .
171  IDEN  flag
171  OPER  =
171  INTE  1
171  SPEC  ;
172  IDEN  token_list
172  OPER  [
172  IDEN  index
172  OPER  ]
172  FLOT  .
172  IDEN  s
172  OPER  =
172  IDEN  s
172  SPEC  ;
173  IDEN  token_list
173  OPER  [
173  IDEN  index
173  OPER  ]
173  FLOT  .
173  IDEN  word
173  OPER  [
173  INTE  0
173  OPER  ]
173  OPER  =
173  IDEN  c
173  SPEC  ;
174  IDEN  token_list
174  OPER  [
174  IDEN  index
174  OPER  ]
174  FLOT  .
174  IDEN  word
174  OPER  [
174  INTE  1
174  OPER  ]
174  OPER  =
174  IDEN  program
174  OPER  [
174  IDEN  cur_i
174  INTE  +
174  INTE  1
174  OPER  ]
174  SPEC  ;
175  IDEN  cur_i
175  INTE  +
175  OPER  =
175  INTE  2
175  SPEC  ;
176  REWD  while
176  SPEC  (
176  IDEN  program
176  OPER  [
176  IDEN  cur_i
176  OPER  ]
176  OPER  =
176  CHAR  '
176  OPER  /
176  CHAR  '
176  SPEC  )
177  SPEC  {
178  REWD  if
178  SPEC  (
178  IDEN  program
178  OPER  [
178  IDEN  cur_i
178  OPER  ]
178  OPER  =
178  CHAR  '
178  OPER  \
178  IDEN  n
178  CHAR  '
178  SPEC  )
179  SPEC  {
180  IDEN  s
180  INTE  +
180  OPER  =
180  INTE  1
180  SPEC  ;
181  IDEN  cur_i
181  INTE  +
181  OPER  =
181  INTE  1
181  SPEC  ;
182  REWD  continue
182  SPEC  ;
183  SPEC  }
184  IDEN  cur_i
184  INTE  +
184  OPER  =
184  INTE  1
184  SPEC  ;
185  SPEC  }
186  IDEN  cur_i
186  INTE  +
186  OPER  =
186  INTE  1
186  SPEC  ;
187  IDEN  token_list
187  OPER  [
187  IDEN  index
187  OPER  ]
187  FLOT  .e
187  OPER  =
187  IDEN  s
187  SPEC  ;
188  IDEN  index
188  INTE  +
188  OPER  =
188  INTE  1
188  SPEC  ;
189  SPEC  }
190  REWD  else
191  SPEC  {
192  REWD  if
192  SPEC  (
192  IDEN  check_spec
192  SPEC  (
192  IDEN  c
192  SPEC  )
192  OPER  =
192  INTE  1
192  SPEC  )
193  SPEC  {
194  REWD  for
194  SPEC  (
194  IDEN  size_t
194  IDEN  i
194  OPER  =
194  INTE  0
194  SPEC  ;
194  IDEN  i
194  OPER  <
194  INTE  7
194  SPEC  ;
194  IDEN  i
194  INTE  ++
194  SPEC  )
195  SPEC  {
196  REWD  if
196  SPEC  (
196  IDEN  c
196  OPER  =
196  IDEN  SPEC
196  OPER  [
196  IDEN  i
196  OPER  ]
196  SPEC  )
197  SPEC  {
198  IDEN  token_list
198  OPER  [
198  IDEN  index
198  OPER  ]
198  FLOT  .
198  IDEN  s
198  OPER  =
198  IDEN  s
198  SPEC  ;
199  IDEN  token_list
199  OPER  [
199  IDEN  index
199  OPER  ]
199  FLOT  .
199  IDEN  token
199  OPER  =
199  STR  "
199  IDEN  SPEC
199  STR  "
199  SPEC  ;
200  IDEN  token_list
200  OPER  [
200  IDEN  index
200  OPER  ]
200  FLOT  .
200  IDEN  word
200  OPER  [
200  INTE  0
200  OPER  ]
200  OPER  =
200  IDEN  c
200  SPEC  ;
201  IDEN  index
201  INTE  +
201  OPER  =
201  INTE  1
201  SPEC  ;
202  IDEN  cur_i
202  INTE  +
202  OPER  =
202  INTE  1
202  SPEC  ;
203  SPEC  }
204  SPEC  }
205  SPEC  }
206  REWD  else
207  SPEC  {
208  REWD  int
208  IDEN  flag
208  OPER  =
208  INTE  0
208  SPEC  ;
209  REWD  for
209  SPEC  (
209  REWD  int
209  IDEN  i
209  OPER  =
209  INTE  0
209  SPEC  ;
209  IDEN  i
209  OPER  <
209  INTE  31
209  SPEC  ;
209  IDEN  i
209  INTE  ++
209  SPEC  )
210  SPEC  {
211  REWD  if
211  SPEC  (
211  IDEN  strlen
211  SPEC  (
211  IDEN  OPER
211  OPER  [
211  IDEN  i
211  OPER  ]
211  SPEC  )
211  OPER  =
211  INTE  2
211  SPEC  )
212  SPEC  {
213  REWD  if
213  SPEC  (
213  IDEN  program
213  OPER  [
213  IDEN  cur_i
213  INTE  +
213  INTE  1
213  OPER  ]
213  OPER  =
213  IDEN  OPER
213  OPER  [
213  IDEN  i
213  OPER  ]
213  OPER  [
213  INTE  1
213  OPER  ]
213  SPEC  )
214  SPEC  {
215  IDEN  flag
215  OPER  =
215  INTE  1
215  SPEC  ;
216  SPEC  }
217  SPEC  }
218  SPEC  }
219  REWD  if
219  SPEC  (
219  IDEN  flag
219  OPER  =
219  INTE  1
219  SPEC  )
220  SPEC  {
221  IDEN  token_list
221  OPER  [
221  IDEN  index
221  OPER  ]
221  FLOT  .
221  IDEN  s
221  OPER  =
221  IDEN  s
221  SPEC  ;
222  IDEN  token_list
222  OPER  [
222  IDEN  index
222  OPER  ]
222  FLOT  .
222  IDEN  token
222  OPER  =
222  STR  "
222  IDEN  OPER
222  STR  "
222  SPEC  ;
223  IDEN  token_list
223  OPER  [
223  IDEN  index
223  OPER  ]
223  FLOT  .
223  IDEN  word
223  OPER  [
223  INTE  0
223  OPER  ]
223  OPER  =
223  IDEN  program
223  OPER  [
223  IDEN  cur_i
223  OPER  ]
223  SPEC  ;
224  IDEN  token_list
224  OPER  [
224  IDEN  index
224  OPER  ]
224  FLOT  .
224  IDEN  word
224  OPER  [
224  INTE  0
224  OPER  ]
224  OPER  =
224  IDEN  program
224  OPER  [
224  IDEN  cur_i
224  INTE  +
224  INTE  1
224  OPER  ]
224  SPEC  ;
225  IDEN  index
225  INTE  +
225  OPER  =
225  INTE  1
225  SPEC  ;
226  IDEN  cur_i
226  INTE  +
226  OPER  =
226  INTE  2
226  SPEC  ;
227  SPEC  }
228  REWD  else
229  SPEC  {
230  IDEN  token_list
230  OPER  [
230  IDEN  index
230  OPER  ]
230  FLOT  .
230  IDEN  s
230  OPER  =
230  IDEN  s
230  SPEC  ;
231  IDEN  token_list
231  OPER  [
231  IDEN  index
231  OPER  ]
231  FLOT  .
231  IDEN  token
231  OPER  =
231  STR  "
231  IDEN  OPER
231  STR  "
231  SPEC  ;
232  IDEN  token_list
232  OPER  [
232  IDEN  index
232  OPER  ]
232  FLOT  .
232  IDEN  word
232  OPER  [
232  INTE  0
232  OPER  ]
232  OPER  =
232  IDEN  program
232  OPER  [
232  IDEN  cur_i
232  OPER  ]
232  SPEC  ;
233  IDEN  index
233  INTE  +
233  OPER  =
233  INTE  1
233  SPEC  ;
234  IDEN  cur_i
234  INTE  +
234  OPER  =
234  INTE  1
234  SPEC  ;
235  SPEC  }
236  SPEC  }
237  SPEC  }
238  SPEC  }
239  SPEC  }
241  REWD  int
241  IDEN  main
241  SPEC  (
241  SPEC  )
242  SPEC  {
243  SC  //
243  IDEN  Open
243  IDEN  the
243  IDEN  input
243  IDEN  file
244  IDEN  FILE
244  OPER  *
244  IDEN  input_file
244  OPER  =
244  IDEN  fopen
244  SPEC  (
244  STR  "
244  IDEN  scanner1
244  FLOT  .
244  IDEN  c
244  STR  "
244  OPER  ,
244  STR  "
244  IDEN  r
244  STR  "
244  SPEC  )
244  SPEC  ;
245  REWD  if
245  SPEC  (
245  OPER  !
245  IDEN  input_file
245  SPEC  )
246  SPEC  {
247  IDEN  printf
247  SPEC  (
247  STR  "
247  IDEN  Unable
247  IDEN  to
247  IDEN  open
247  IDEN  input
247  IDEN  file
247  FLOT  .
247  STR  "
247  SPEC  )
247  SPEC  ;
248  REWD  return
248  INTE  1
248  SPEC  ;
249  SPEC  }
250  REWD  else
251  SPEC  {
252  IDEN  printf
252  SPEC  (
252  STR  "
252  IDEN  Input
252  IDEN  file
252  IDEN  opened
252  IDEN  successfully
252  FLOT  .
252  OPER  \
252  IDEN  n
252  STR  "
252  SPEC  )
252  SPEC  ;
253  REWD  char
253  IDEN  c
253  SPEC  ;
254  REWD  int
254  IDEN  count
254  OPER  =
254  INTE  0
254  SPEC  ;
255  REWD  do
256  SPEC  {
257  SC  //
257  IDEN  Read
257  IDEN  the
257  IDEN  characters
257  IDEN  from
257  IDEN  the
257  IDEN  input
257  IDEN  file
258  IDEN  c
258  OPER  =
258  IDEN  fgetc
258  SPEC  (
258  IDEN  input_file
258  SPEC  )
258  SPEC  ;
259  IDEN  program
259  OPER  [
259  IDEN  count
259  OPER  ]
259  OPER  =
259  IDEN  c
259  SPEC  ;
260  IDEN  count
260  INTE  +
260  OPER  =
260  INTE  1
260  SPEC  ;
261  IDEN  printf
261  SPEC  (
261  STR  "
261  OPER  %
261  IDEN  c
261  STR  "
261  OPER  ,
261  IDEN  c
261  SPEC  )
261  SPEC  ;
262  SPEC  }
262  REWD  while
262  SPEC  (
262  IDEN  c
262  OPER  =
262  IDEN  EOF
262  SPEC  )
262  SPEC  ;
264  IDEN  s
264  OPER  =
264  INTE  1
264  SPEC  ;
265  IDEN  index
265  OPER  =
265  INTE  0
265  SPEC  ;
266  IDEN  cur_i
266  OPER  =
266  INTE  0
266  SPEC  ;
268  REWD  while
268  SPEC  (
268  IDEN  cur_i
268  OPER  <
268  IDEN  count
268  SPEC  )
269  SPEC  {
270  SC  //
270  IDEN  Handle
270  IDEN  newline
270  IDEN  character
271  REWD  if
271  SPEC  (
271  IDEN  program
271  OPER  [
271  IDEN  cur_i
271  OPER  ]
271  OPER  =
271  CHAR  '
271  OPER  \
271  IDEN  n
271  CHAR  '
271  SPEC  )
272  SPEC  {
273  IDEN  s
273  INTE  +
273  OPER  =
273  INTE  1
273  SPEC  ;
274  IDEN  cur_i
274  INTE  +
274  OPER  =
274  INTE  1
274  SPEC  ;
275  REWD  continue
275  SPEC  ;
276  SPEC  }
277  IDEN  c
277  OPER  =
277  IDEN  program
277  OPER  [
277  IDEN  cur_i
277  OPER  ]
277  SPEC  ;
278  SC  //
278  IDEN  Handle
278  IDEN  identifiers
279  REWD  if
279  SPEC  (
279  SPEC  (
279  CHAR  '
279  IDEN  a
279  CHAR  '
279  OPER  =
279  IDEN  c
279  OPER  &
279  IDEN  c
279  OPER  =
279  CHAR  '
279  IDEN  z
279  CHAR  '
279  SPEC  )
279  OPER  |
279  SPEC  (
279  CHAR  '
279  IDEN  A
279  CHAR  '
279  OPER  =
279  IDEN  c
279  OPER  &
279  IDEN  c
279  OPER  =
279  CHAR  '
279  IDEN  Z
279  CHAR  '
279  SPEC  )
279  OPER  |
279  IDEN  c
279  OPER  =
279  CHAR  '
279  IDEN  _
279  CHAR  '
279  SPEC  )
280  SPEC  {
281  IDEN  identifier
281  SPEC  (
281  SPEC  )
281  SPEC  ;
282  SPEC  }
283  SC  //
283  IDEN  Handle
283  IDEN  numbers
284  REWD  else
284  REWD  if
284  SPEC  (
284  IDEN  isdigit
284  SPEC  (
284  IDEN  c
284  SPEC  )
284  OPER  |
284  IDEN  c
284  OPER  =
284  CHAR  '
284  FLOT  .
284  CHAR  '
284  OPER  |
284  IDEN  c
284  OPER  =
284  CHAR  '
284  IDEN  e
284  CHAR  '
284  OPER  |
284  IDEN  c
284  OPER  =
284  CHAR  '
284  IDEN  E
284  CHAR  '
284  OPER  |
284  IDEN  c
284  OPER  =
284  CHAR  '
284  INTE  +
284  CHAR  '
284  OPER  |
284  IDEN  c
284  OPER  =
284  CHAR  '
284  INTE  -
284  CHAR  '
284  SPEC  )
285  SPEC  {
286  IDEN  number
286  SPEC  (
286  SPEC  )
286  SPEC  ;
287  SPEC  }
288  SC  //
288  IDEN  Handle
288  IDEN  special
288  IDEN  symbols
289  REWD  else
290  SPEC  {
291  REWD  if
291  SPEC  (
291  IDEN  isspace
291  SPEC  (
291  IDEN  program
291  OPER  [
291  IDEN  cur_i
291  OPER  ]
291  SPEC  )
291  SPEC  )
292  SPEC  {
293  IDEN  cur_i
293  INTE  +
293  OPER  =
293  INTE  1
293  SPEC  ;
294  REWD  continue
294  SPEC  ;
295  SPEC  }
296  IDEN  special_symbols
296  SPEC  (
296  SPEC  )
296  SPEC  ;
297  SPEC  }
298  SPEC  }
299  SC  //
299  IDEN  Open
299  IDEN  the
299  IDEN  output
299  IDEN  file
300  IDEN  FILE
300  OPER  *
300  IDEN  output_file
300  OPER  =
300  IDEN  fopen
300  SPEC  (
300  STR  "
300  IDEN  scannerOut2
300  FLOT  .
300  IDEN  txt
300  STR  "
300  OPER  ,
300  STR  "
300  IDEN  w
300  STR  "
300  SPEC  )
300  SPEC  ;
301  REWD  if
301  SPEC  (
301  OPER  !
301  IDEN  output_file
301  SPEC  )
302  SPEC  {
303  IDEN  printf
303  SPEC  (
303  STR  "
303  IDEN  Unable
303  IDEN  to
303  IDEN  open
303  IDEN  output
303  IDEN  file
303  FLOT  .
303  STR  "
303  SPEC  )
303  SPEC  ;
304  REWD  return
304  INTE  1
304  SPEC  ;
305  SPEC  }
306  REWD  else
307  SPEC  {
308  SC  //
308  IDEN  Print
308  IDEN  tokens
308  IDEN  to
308  IDEN  the
308  IDEN  console
308  IDEN  and
308  IDEN  write
308  IDEN  them
308  IDEN  to
308  IDEN  the
308  IDEN  output
308  IDEN  file
309  REWD  for
309  SPEC  (
309  IDEN  size_t
309  IDEN  i
309  OPER  =
309  INTE  0
309  SPEC  ;
309  IDEN  i
309  OPER  <
309  INTE  10000
309  SPEC  ;
309  IDEN  i
309  INTE  ++
309  SPEC  )
310  SPEC  {
311  REWD  if
311  SPEC  (
311  IDEN  token_list
311  OPER  [
311  IDEN  i
311  OPER  ]
311  FLOT  .
311  IDEN  s
311  OPER  =
311  INTE  0
311  SPEC  )
312  SPEC  {
313  REWD  break
313  SPEC  ;
314  SPEC  }
315  IDEN  printf
315  SPEC  (
315  STR  "
315  OPER  %
315  IDEN  d
315  OPER  %
315  IDEN  s
315  OPER  %
315  IDEN  s
315  OPER  \
315  IDEN  n
315  STR  "
315  OPER  ,
315  IDEN  token_list
315  OPER  [
315  IDEN  i
315  OPER  ]
315  FLOT  .
315  IDEN  s
315  OPER  ,
315  IDEN  token_list
315  OPER  [
315  IDEN  i
315  OPER  ]
315  FLOT  .
315  IDEN  token
315  OPER  ,
315  IDEN  token_list
315  OPER  [
315  IDEN  i
315  OPER  ]
315  FLOT  .
315  IDEN  word
315  SPEC  )
315  SPEC  ;
316  IDEN  fprintf
316  SPEC  (
316  IDEN  output_file
316  OPER  ,
316  STR  "
316  OPER  %
316  IDEN  d
316  OPER  %
316  IDEN  s
316  OPER  %
316  IDEN  s
316  OPER  \
316  IDEN  n
316  STR  "
316  OPER  ,
316  IDEN  token_list
316  OPER  [
316  IDEN  i
316  OPER  ]
316  FLOT  .
316  IDEN  s
316  OPER  ,
316  IDEN  token_list
316  OPER  [
316  IDEN  i
316  OPER  ]
316  FLOT  .
316  IDEN  token
316  OPER  ,
316  IDEN  token_list
316  OPER  [
316  IDEN  i
316  OPER  ]
316  FLOT  .
316  IDEN  word
316  SPEC  )
316  SPEC  ;
317  SPEC  }
318  IDEN  fclose
318  SPEC  (
318  IDEN  output_file
318  SPEC  )
318  SPEC  ;
319  IDEN  fclose
319  SPEC  (
319  IDEN  input_file
319  SPEC  )
319  SPEC  ;
320  SPEC  }
321  SPEC  }
322  REWD  return
322  INTE  0
322  SPEC  ;
323  SPEC  }
325  OPER  ÿ
